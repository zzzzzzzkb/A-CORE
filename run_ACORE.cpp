// A-CORE main search executable
//
// This file runs the final A-CORE search procedure used in the
// experiments of the accompanying anonymous paper. It consumes:
//   (1) clustered query data generated by make_clustered_queries5.cpp,
//   (2) per-cluster training features produced by run_train_get_all_k_onlytop.cpp,
//   (3) LightGBM models trained by train_full_conditional_and_recall_newfeat.py.
//
// For end-to-end usage, see the README in this code package.

#include <hnswlib/hnswlib.h>
#include <algorithm>
#include <cassert>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <filesystem>
#include <iostream>
#include <limits>
#include <numeric>
#include <random>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <vector>
#include <cstring>
#include <cmath>
#include <set>
#include <fstream>
#include <sstream>
#include <iomanip>
#include "json.hpp"
#include <string>

using json = nlohmann::json;

struct FeatureBank {
    std::unordered_map<std::string, float> kv;

    float get(const std::string& name, float default_val = 0.0f) const {
        auto it = kv.find(name);
        return (it == kv.end()) ? default_val : it->second;
    }
};

// 工具：按名字顺序拼出向量
static std::vector<float> vector_from_names(
    const std::vector<std::string>& names,
    const FeatureBank& F
){
    std::vector<float> x; x.reserve(names.size());
    for (auto& n : names) x.push_back(F.get(n, 0.0f));
    return x;
}
using idx_t = size_t;

// ================================================
// Minimal LightGBM TXT inference (GBDT)
// ================================================
struct GBDT {
    struct Tree {
        std::vector<int> left_child, right_child, split_feature;
        std::vector<float> threshold, leaf_value;
        int num_leaves = 0;
        int root = 0;
        float predict(const std::vector<float>& feat) const {
            int node = 0;
            while (true) {
                if (node < 0) {
                    int leaf_idx = -1 - node;
                    if (leaf_idx >= 0 && leaf_idx < (int)leaf_value.size()) return leaf_value[leaf_idx];
                    return 0.f;
                }
                if (node >= (int)split_feature.size()) {
                    if (!leaf_value.empty()) return leaf_value[0];
                    return 0.f;
                }
                int f = split_feature[node];
                float thr = threshold[node];
                float x = (f>=0 && f<(int)feat.size()) ? feat[f] : 0.f;
                int nxt = (x <= thr) ? left_child[node] : right_child[node];
                node = nxt;
            }
        }
    };

    std::vector<Tree> trees;

    static std::string trim(const std::string& s){
        size_t a = s.find_first_not_of(" \t\r\n");
        size_t b = s.find_last_not_of(" \t\r\n");
        if (a==std::string::npos) return "";
        return s.substr(a, b-a+1);
    }

    bool load_from_txt(const std::string& path){
        std::ifstream fin(path);
        if (!fin) { std::cerr<<"[GBDT] cannot open "<<path<<"\n"; return false; }
        trees.clear();
        std::string line; Tree cur;
        auto flush_tree=[&](){
            if (!cur.split_feature.empty() || !cur.leaf_value.empty()){
                trees.push_back(std::move(cur));
                cur = Tree();
            }
        };
        while (std::getline(fin, line)){
            line = trim(line);
            if (line.rfind("Tree=",0)==0){ flush_tree(); continue; }
            if (line.rfind("num_leaves=",0)==0){ cur.num_leaves = std::stoi(line.substr(11)); continue; }
            if (line.rfind("split_feature=",0)==0){
                std::string s = line.substr(14);
                cur.split_feature.clear();
                std::stringstream ss(s);
                std::string tok;
                while (std::getline(ss, tok, ' ')){
                    tok = trim(tok);
                    if (tok.empty()) continue;
                    cur.split_feature.push_back(std::stoi(tok));
                }
                continue;
            }
            if (line.rfind("threshold=",0)==0){
                std::string s = line.substr(10);
                cur.threshold.clear();
                std::stringstream ss(s);
                std::string tok;
                while (std::getline(ss, tok, ' ')){
                    tok = trim(tok);
                    if (tok.empty()) continue;
                    cur.threshold.push_back(std::stof(tok));
                }
                continue;
            }
            if (line.rfind("left_child=",0)==0){
                std::string s = line.substr(11);
                cur.left_child.clear();
                std::stringstream ss(s);
                std::string tok;
                while (std::getline(ss, tok, ' ')){
                    tok = trim(tok);
                    if (tok.empty()) continue;
                    cur.left_child.push_back(std::stoi(tok));
                }
                continue;
            }
            if (line.rfind("right_child=",0)==0){
                std::string s = line.substr(12);
                cur.right_child.clear();
                std::stringstream ss(s);
                std::string tok;
                while (std::getline(ss, tok, ' ')){
                    tok = trim(tok);
                    if (tok.empty()) continue;
                    cur.right_child.push_back(std::stoi(tok));
                }
                continue;
            }
            if (line.rfind("leaf_value=",0)==0){
                std::string s = line.substr(11);
                cur.leaf_value.clear();
                std::stringstream ss(s);
                std::string tok;
                while (std::getline(ss, tok, ' ')){
                    tok = trim(tok);
                    if (tok.empty()) continue;
                    cur.leaf_value.push_back(std::stof(tok));
                }
                continue;
            }
        }
        flush_tree();
        if (trees.empty()){
            std::cerr<<"[GBDT] no trees parsed from "<<path<<"\n";
            return false;
        }
        return true;
    }

    float predict_sum(const std::vector<float>& feat) const {
        double s = 0.0;
        for (const auto& t: trees) s += (double)t.predict(feat);
        return (float)s;
    }
};

struct PiecewiseLinear {
    std::vector<float> xs, ys;
    float eval(float x) const {
        if (xs.empty()) return x;
        if (x <= xs.front()) return ys.front();
        if (x >= xs.back())  return ys.back();
        auto it = std::upper_bound(xs.begin(), xs.end(), x);
        size_t j = size_t(it - xs.begin());
        size_t i = j - 1;
        float t = (x - xs[i]) / (xs[j] - xs[i] + 1e-12f);
        return ys[i] + t * (ys[j] - ys[i]);
    }
};

struct RecallHead {
    std::vector<std::string> names;
    std::vector<float> coef;
    PiecewiseLinear mapS, mapC, mapU;

    float base_z(const std::vector<float>& f_base, float S_val, float COV_val) const {
        size_t idx = 0;
        float z = 0.f;
        z += coef[idx++];
        for (size_t i = 0; i < f_base.size(); ++i) z += coef[idx++] * f_base[i];
        z += coef[idx++] * S_val;
        z += coef[idx++] * COV_val;
        return z;
    }
    float solve_phi_min(float logit_Rstar,
                        const std::vector<float>& f_base,
                        float S_val, float COV_val,
                        float phi_lo) const
    {
        if (coef.empty()) return 1.f;
        float bU = coef.back();
        float z0 = base_z(f_base, S_val, COV_val);
        auto meets = [&](float phi){
            return (z0 + bU * mapU.eval(phi)) >= logit_Rstar;
        };
        phi_lo = std::min(std::max(phi_lo, 0.f), 1.f);
        if (bU <= 1e-12f) return 1.f;
        if (meets(phi_lo)) return phi_lo;
        float lo = phi_lo, hi = 1.f;
        for (int it = 0; it < 24; ++it) {
            float mid = 0.5f * (lo + hi);
            if (meets(mid)) hi = mid;
            else            lo = mid;
        }
        return hi;
    }
};

static inline float sigmoid(float z){ return 1.f/(1.f+std::exp(-z)); }
static inline float logit_clip(float r){
    const float eps = 1e-5f;
    float x = std::min(std::max(r, eps), 1.f-eps);
    return std::log(x/(1.f-x));
}

// ---------- 简易 RAII 计时器 ----------
struct ScopeTimer {
    std::chrono::high_resolution_clock::time_point t0;
    double* acc;
    explicit ScopeTimer(double& x): t0(std::chrono::high_resolution_clock::now()), acc(&x) {}
    ~ScopeTimer(){
        auto t1 = std::chrono::high_resolution_clock::now();
        *acc += std::chrono::duration<double>(t1 - t0).count();
    }
};

// ---------- I/O ----------
static idx_t read_fbin(const char* f, std::vector<float>& out, int& dim) {
    FILE* fp = fopen(f, "rb"); if (!fp) { perror(f); std::exit(1); }
    int n=0,d=0; fread(&n,4,1,fp); fread(&d,4,1,fp);
    out.resize((idx_t)n*(idx_t)d);
    size_t tot=(size_t)n*(size_t)d;
    if (fread(out.data(), sizeof(float), tot, fp)!=tot) { std::cerr<<"read "<<f<<" fail\n"; std::exit(1); }
    fclose(fp); dim=d; return (idx_t)n;
}
static idx_t read_ibin(const char* f, std::vector<int>& out, int& dim) {
    FILE* fp = fopen(f, "rb"); if (!fp) { perror(f); std::exit(1); }
    int n=0,d=0; fread(&n,4,1,fp); fread(&d,4,1,fp);
    out.resize((idx_t)n*(idx_t)d);
    size_t tot=(size_t)n*(size_t)d;
    if (fread(out.data(), sizeof(int), tot, fp)!=tot) { std::cerr<<"read "<<f<<" fail\n"; std::exit(1); }
    fclose(fp); dim=d; return (idx_t)n;
}
static inline float l2sq(const float* a, const float* b, int d) {
    float s=0.f; for (int i=0;i<d;++i){ float df=a[i]-b[i]; s+=df*df; } return s;
}
static double topk_overlap_ratio_limited(const std::vector<hnswlib::tableint>& A,
                                         const std::vector<hnswlib::tableint>& B,
                                         int K){
    size_t Ke = (size_t)std::max(0, K);
    Ke = std::min<size_t>(Ke, std::min(A.size(), B.size()));
    if (Ke == 0) return 0.0;
    std::unordered_set<hnswlib::tableint> sa; sa.reserve(Ke*2);
    std::unordered_set<hnswlib::tableint> sb; sb.reserve(Ke*2);
    for(size_t i=0;i<Ke;++i) sa.insert(A[i]);
    for(size_t i=0;i<Ke;++i) sb.insert(B[i]);
    size_t inter=0;
    if(sa.size()<sb.size()){ for(auto v: sa) if(sb.count(v)) ++inter; }
    else { for(auto v: sb) if(sa.count(v)) ++inter; }
    return (double)inter / (double)Ke;
}
static double topk_jaccard_limited(const std::vector<hnswlib::tableint>& A,
                                   const std::vector<hnswlib::tableint>& B,
                                   int K){
    size_t Ke = (size_t)std::max(0, K);
    Ke = std::min<size_t>(Ke, std::min(A.size(), B.size()));
    if (Ke == 0) return 0.0;
    std::unordered_set<hnswlib::tableint> s; s.reserve(Ke*3);
    size_t inter=0;
    for(size_t i=0;i<Ke;++i) s.insert(A[i]);
    for(size_t i=0;i<Ke;++i) inter += s.count(B[i]) ? 1 : 0;
    for(size_t i=0;i<Ke;++i) s.insert(B[i]);
    size_t uni = s.size();
    return (uni>0)? (double)inter/(double)uni : 0.0;
}

// --- NEW: compute LID/RC/Expansion from a sorted top-id list ---
static void compute_lid_rc_expansion_from_top(
    const hnswlib::HierarchicalNSW<float>& hnsw,
    const float* qvec, int dim,
    const std::vector<hnswlib::tableint>& top_ids, // assumed ascending by distance
    int k,
    float& out_lid, float& out_rc, float& out_expand2k_over_k)
{
    out_lid = 0.f; out_rc = 0.f; out_expand2k_over_k = 1.f;
    if (top_ids.empty() || k <= 0) return;

    std::vector<float> d; d.reserve(top_ids.size());
    for (auto id: top_ids){
        const float* xv = reinterpret_cast<const float*>(hnsw.getDataByInternalId(id));
        d.push_back(std::sqrt(l2sq(qvec, xv, dim)));
    }
    std::sort(d.begin(), d.end());
    int kk = std::min(k, (int)d.size());
    if (kk <= 0) return;

    const float eps = 1e-12f;
    float r_k = d[kk-1];
    // LID
    float s = 0.f;
    for (int i=0;i<kk;++i){
        float ratio = (r_k > eps) ? (d[i]/(r_k+eps)) : 1.f;
        ratio = std::max(ratio, eps);
        s += std::log(ratio);
    }
    float mean_log = s / std::max(1, kk);
    out_lid = (std::abs(mean_log) > 1e-12f) ? (-1.0f/mean_log) : 0.f;

    // RC = d_mean / r_k  (use mean over the available top list)
    double mean = 0.0; for (float v: d) mean += v; mean /= (double)std::max<size_t>(1, d.size());
    out_rc = (r_k > eps) ? (float)(mean / r_k) : 0.f;

    // Expansion_{2k|k} = r_{2k} / r_k  (cap 2k at the available length)
    int k2 = std::min((int)d.size(), kk*2);
    float r_k2 = d[k2-1];
    out_expand2k_over_k = (r_k > eps) ? (r_k2 / r_k) : 1.f;
}

// 计算 recall@k
static float compute_recall(const std::vector<std::vector<idx_t>>& results,
                           const std::vector<int>& gt,
                           int k, int nq) {
    int total_correct = 0;
    int total_expected = 0;
    int expected = std::min(k, (int)gt.size() / nq);
    for (int i = 0; i < nq; ++i) {
        int correct = 0;
        for (int j = 0; j < expected; ++j) {
            int gt_id = gt[i * (int)(gt.size() / nq) + j];
            if (gt_id < 0) break;
            for (int t = 0; t < std::min(k, (int)results[i].size()); ++t) {
                if (results[i][t] == (idx_t)gt_id) {
                    correct++;
                    break;
                }
            }
        }
        total_correct += correct;
        total_expected += expected;
    }
    return total_expected > 0 ? (float)total_correct / (float)total_expected : 0.0f;
}
static std::string first_existing(const std::string& dir, const std::vector<std::string>& names) {
    for (auto& n: names){ auto p=dir+"/"+n; if (std::filesystem::exists(p)) return p; }
    return dir + "/" + names.front();
}
// 计算指定 qids 子集的 recall@k（gt 已裁成 nq x k）
static float compute_recall_subset(const std::vector<std::vector<idx_t>>& results,
                                   const std::vector<int>& gt,
                                   int k,
                                   const std::vector<idx_t>& qids) {
    int nq = (int)results.size();
    if (nq == 0) return 0.f;
    int per_row = (int)gt.size() / nq; // == k
    int expect  = std::min(k, per_row);

    long long tot_hit = 0, tot_need = 0;
    for (auto qi : qids){
        int hit = 0;
        const auto& R = results[qi];
        for (int j=0; j<expect; ++j){
            int g = gt[(size_t)qi * per_row + j];
            if (g < 0) break;
            for (int t=0; t<std::min((int)R.size(), k); ++t){
                if ((int)R[t] == g){ ++hit; break; }
            }
        }
        tot_hit  += hit;
        tot_need += expect;
    }
    return tot_need>0 ? (float)tot_hit/(float)tot_need : 0.f;
}

// ---------- 简易 KMeans（保留） ----------
struct KMeansOut{ std::vector<int> labels; std::vector<float> centroids; };
static KMeansOut kmeans(const std::vector<float>& X, idx_t n, int d, int k, int iters, unsigned seed){
    KMeansOut out; out.labels.assign(n,-1); out.centroids.assign((size_t)k*d,0.f);
    std::mt19937 rng(seed); std::unordered_set<int> chosen;
    while ((int)chosen.size()<k) chosen.insert((int)(rng()%n));
    int ci=0; for (int id: chosen){ std::copy(X.data()+ (size_t)id*d, X.data()+ (size_t)id*d+d, out.centroids.data()+ (size_t)ci*d); ++ci; }
    std::vector<float> newc((size_t)k*d,0.f); std::vector<int> cnt(k,0);
    auto assign=[&](){ bool ch=false; for (idx_t i=0;i<n;++i){ const float* xi=X.data()+i*d; int best=0; float bd=1e38f;
        for (int c=0;c<k;++c){ float dd=l2sq(xi,out.centroids.data()+ (size_t)c*d,d); if (dd<bd){bd=dd;best=c;} }
        if (out.labels[i]!=best){ out.labels[i]=best; ch=true; } } return ch; };
    auto update=[&](){ std::fill(newc.begin(),newc.end(),0.f); std::fill(cnt.begin(),cnt.end(),0);
        for (idx_t i=0;i<n;++i){ int c=out.labels[i]; if (c<0) continue; cnt[c]++; const float* xi=X.data()+i*d; float* cc=newc.data()+ (size_t)c*d;
            for (int t=0;t<d;++t) cc[t]+=xi[t]; }
        for (int c=0;c<k;++c){ float* cc=out.centroids.data()+ (size_t)c*d; if (cnt[c]>0){ for (int t=0;t<d;++t) cc[t]=newc[(size_t)c*d+t]/cnt[c]; } } };
    for (int it=0; it<iters; ++it){ bool ch=assign(); update(); if(!ch) break; }
    return out;
}

// ---------- 扩展 HNSW：暴露 L0 邻接 & 从“当时工具”继续 ----------
struct WarmHierarchicalNSW : public hnswlib::HierarchicalNSW<float> {
    using Base=hnswlib::HierarchicalNSW<float>;
    using tableint=hnswlib::tableint; using labeltype=hnswlib::labeltype;
    explicit WarmHierarchicalNSW(hnswlib::SpaceInterface<float>* s, size_t max_elements, size_t M, size_t efc)
        : Base(s, max_elements, M, efc) {}
    const hnswlib::linklistsizeint* linklist0(tableint id) const { return this->get_linklist0(id); }
    tableint entrypoint() const { return this->enterpoint_node_; }

    // ---- 细粒度计时 ----
    struct ProfileTimes {
        // 原有
        double t_try_emplace_cand = 0.0;
        double t_try_emplace_top  = 0.0;
        double t_while_expand     = 0.0;
        double t_centroid_search  = 0.0;
        long long cnt_try_cand    = 0;
        long long cnt_try_top     = 0;
        long long cnt_centroid_search = 0;

        // 新增补全簇内搜索里的“缺口”
        double t_visitlist_get    = 0.0;
        double t_visitlist_release= 0.0;
        double t_export_sort_cand = 0.0;
        double t_export_sort_top  = 0.0;
        double t_heap_shrink_topk = 0.0;
        double t_heap_to_res      = 0.0;  // 从 top 转成 res（含 external label 映射）
        double t_result_vectorize = 0.0;  // res -> vector + reverse（在 runner 里加）

        long long cnt_visit_get = 0;
        long long cnt_visit_rel = 0;
    } mutable pt_;

    // 计算 query 的 L0 入口点
    tableint entryPointL0ForQuery(const void* q) const {
        if (this->enterpoint_node_ == (tableint)-1 || this->cur_element_count == 0) return (tableint)-1;
        tableint curr = this->enterpoint_node_;
        float currDist = this->fstdistfunc_(q, this->getDataByInternalId(curr), this->dist_func_param_);
        int currLevel = this->maxlevel_;
        for (int level = currLevel; level > 0; --level) {
            bool changed = true;
            while (changed) {
                changed = false;
                const auto* ll = this->get_linklist(curr, level);
                if (!ll) break;
                unsigned sz = *ll;
                const tableint* nb = reinterpret_cast<const tableint*>(ll + 1);
                for (unsigned i = 0; i < sz; ++i) {
                    tableint v = nb[i];
                    float d = this->fstdistfunc_(q, this->getDataByInternalId(v), this->dist_func_param_);
                    if (d < currDist) { currDist = d; curr = v; changed = true; }
                }
            }
        }
        return curr;
    }

    // 质心一次纯 L0 搜索
    void searchL0Heaps(const void* q, size_t ef,
                       std::vector<tableint>& out_cand_ids,
                       std::vector<tableint>& out_top_ids,
                       std::vector<tableint>& out_visited_ids) const
    {
        out_cand_ids.clear(); out_top_ids.clear(); out_visited_ids.clear();
        if (this->cur_element_count == 0) return;

        hnswlib::VisitedList* vl = nullptr;
        {
            ScopeTimer _t(pt_.t_visitlist_get);
            ++pt_.cnt_visit_get;
            vl = this->visited_list_pool_->getFreeVisitedList();
        }
        vl->reset();
        auto* vis = vl->mass;

        struct MinCmp { bool operator()(const std::pair<float,tableint>&a,const std::pair<float,tableint>&b) const {return a.first>b.first;} };
        std::priority_queue<std::pair<float,tableint>, std::vector<std::pair<float,tableint>>, MinCmp> cand;
        std::priority_queue<std::pair<float,tableint>> top;

        auto mark = [&](tableint id){
            if (id>=this->cur_element_count) return false;
            if (vis[id]==vl->curV) return false;
            vis[id]=vl->curV; out_visited_ids.push_back(id); return true;
        };

        auto push_both = [&](tableint id, float d){
            cand.emplace(d,id);
            top.emplace(d,id);
            if (top.size()>ef) top.pop();
        };

        tableint ep = entryPointL0ForQuery(q);
        if (ep == (tableint)-1) ep = this->enterpoint_node_;
        if (ep != (tableint)-1) {
            mark(ep);
            float d0 = this->fstdistfunc_(q, this->getDataByInternalId(ep), this->dist_func_param_);
            push_both(ep, d0);
        }

        float lb = top.empty()? std::numeric_limits<float>::infinity() : top.top().first;

        while (!cand.empty()){
            auto cu = cand.top(); if (cu.first>lb) break; cand.pop();
            const auto* l0 = this->get_linklist0(cu.second);
            unsigned sz=*l0; const auto* nb=reinterpret_cast<const tableint*>(l0+1);
            for (unsigned i=0;i<sz;++i){
                tableint v=nb[i];
                if (!mark(v)) continue;
                float d=this->fstdistfunc_(q,this->getDataByInternalId(v), this->dist_func_param_);
                if (top.size()<ef || d<lb){ cand.emplace(d,v); top.emplace(d,v); if (top.size()>ef) top.pop(); lb=top.top().first; }
            }
        }

        // 导出 cand/top 的 ID（按 distance 升序）
        {
            ScopeTimer _t(pt_.t_export_sort_cand);
            auto cand_copy = cand;
            std::vector<std::pair<float,tableint>> tmp;
            tmp.reserve(ef);
            for (size_t i=0; i<ef && !cand_copy.empty(); ++i){
                tmp.push_back(cand_copy.top());
                cand_copy.pop();
            }
            std::sort(tmp.begin(), tmp.end(), [](const auto& a, const auto& b){ return a.first < b.first; });
            out_cand_ids.reserve(tmp.size());
            for (auto &p : tmp) out_cand_ids.push_back(p.second);
        }
        {
            ScopeTimer _t(pt_.t_export_sort_top);
            auto top_copy = top;
            std::vector<std::pair<float,tableint>> tmp;
            tmp.reserve(ef);
            for (size_t i=0; i<ef && !top_copy.empty(); ++i){
                tmp.push_back(top_copy.top());
                top_copy.pop();
            }
            std::sort(tmp.begin(), tmp.end(), [](const auto& a, const auto& b){ return a.first < b.first; });
            out_top_ids.reserve(tmp.size());
            for (auto &p : tmp) out_top_ids.push_back(p.second);
        }

        {
            ScopeTimer _t(pt_.t_visitlist_release);
            ++pt_.cnt_visit_rel;
            this->visited_list_pool_->releaseVisitedList(vl);
        }
    }

    // 继续在 L0 搜索
    std::priority_queue<std::pair<float,labeltype>>
    continueFromSnapshotL0(const void* q, size_t k,
                           const std::vector<tableint>& init_cand_ids,
                           const std::vector<tableint>& init_top_ids,
                           size_t ef, float m) const {
        hnswlib::VisitedList* vl = nullptr;
        {
            ScopeTimer _t(pt_.t_visitlist_get);
            ++pt_.cnt_visit_get;
            vl = this->visited_list_pool_->getFreeVisitedList();
        }
        vl->reset();
        auto* vis = vl->mass;

        struct MinCmp { bool operator()(const std::pair<float,tableint>&a,const std::pair<float,tableint>&b) const {return a.first>b.first;} };
        std::priority_queue<std::pair<float,tableint>, std::vector<std::pair<float,tableint>>, MinCmp> cand;
        std::priority_queue<std::pair<float,tableint>> top;


        std::vector<std::pair<float,tableint>> total_ids;

        auto try_emplace = [&](tableint id){
            ScopeTimer _t(pt_.t_try_emplace_cand);
            pt_.cnt_try_cand++;
            if (id>=this->cur_element_count) return;
            if (vis[id]!=vl->curV) vis[id]=vl->curV;
            float d = this->fstdistfunc_(q,this->getDataByInternalId(id), this->dist_func_param_);
            cand.emplace(d,id);
            top.emplace(d,id);
        };

        auto try_emplace_cand = [&](tableint id){
            ScopeTimer _t(pt_.t_try_emplace_cand);
            pt_.cnt_try_cand++;
            if (id>=this->cur_element_count) return;
            if (vis[id]!=vl->curV) vis[id]=vl->curV;
            float d = this->fstdistfunc_(q,this->getDataByInternalId(id), this->dist_func_param_);
            cand.emplace(d,id);
        };
        auto try_emplace_top = [&](tableint id){
            ScopeTimer _t(pt_.t_try_emplace_top);
            pt_.cnt_try_top++;
            if (id>=this->cur_element_count) return;
            if (vis[id]!=vl->curV) vis[id]=vl->curV;
            float d = this->fstdistfunc_(q,this->getDataByInternalId(id), this->dist_func_param_);
            top.emplace(d,id);
        };

        int count=0;
        int max_count = m;
        for (auto id: init_top_ids) {
            if(count>=max_count) break;
            // try_emplace_cand(id);
            try_emplace(id);
            ++count;
        }
        count=0;

        {
            ScopeTimer _t(pt_.t_heap_shrink_topk);
            while (top.size()>ef) top.pop();
        }

        float lb = top.empty()? std::numeric_limits<float>::infinity() : top.top().first;

        {
            ScopeTimer _t(pt_.t_while_expand);
            while (!cand.empty()){
                auto cu = cand.top(); if (cu.first>lb) break; cand.pop();
                auto* l0 = this->get_linklist0(cu.second);
                unsigned sz=*l0; auto* nb=reinterpret_cast<tableint*>(l0+1);
                for (unsigned i=0;i<sz;++i){
                    tableint v=nb[i];
                    if (vis[v]==vl->curV) continue;
                    vis[v]=vl->curV;
                    float d=this->fstdistfunc_(q,this->getDataByInternalId(v), this->dist_func_param_);
                    if (top.size()<ef || d<lb){ cand.emplace(d,v); top.emplace(d,v); if (top.size()>ef) top.pop(); lb=top.top().first; }
                }
            }
        }

        this->visited_list_pool_->releaseVisitedList(vl);
        {
            ScopeTimer _t(pt_.t_heap_shrink_topk);
            while (top.size()>k) top.pop();
        }
        std::priority_queue<std::pair<float,labeltype>> res;
        {
            ScopeTimer _t(pt_.t_heap_to_res);
            while(!top.empty()){
                res.emplace(top.top().first, (labeltype)this->getExternalLabel(top.top().second));
                top.pop();
            }
        }
        return res;
    }

    const ProfileTimes& profile_times() const { return pt_; }
};

// ---------- 簇级共识搜索 ----------
struct ClusterConsensusSearch {
    using tableint = hnswlib::tableint;
    const WarmHierarchicalNSW& H; const hnswlib::L2Space& space; int dim; int k;
    ClusterConsensusSearch(const WarmHierarchicalNSW& h, const hnswlib::L2Space& s, int d, int k_)
        : H(h), space(s), dim(d), k(k_) {}

    std::vector<idx_t> run_one_cluster_fixed_c(
        const std::vector<float>& c,
        std::vector<idx_t> queries,
        const std::vector<float>& xq,
        const std::vector<float>& /*xb*/,
        int ef,
        int ef_warm,
        std::vector<idx_t>& out_remain,
        std::vector<std::vector<idx_t>>& out_topk,
        size_t& out_incl_by_bound,
        size_t& out_incl_by_notfull,
        float m,
        std::vector<double>* per_query_time_sec, // 新增：记录每个 query 搜索时间（秒）
        std::vector<hnswlib::tableint> candE, 
        std::vector<hnswlib::tableint> topE
    ) const {
        (void)out_incl_by_bound; (void)out_incl_by_notfull;
        out_incl_by_bound = 0; out_incl_by_notfull = 0;
        out_remain.clear();

        std::vector<tableint> cand_ids, top_ids, vis_ids;
        cand_ids = std::move(candE);
        top_ids  = std::move(topE);
        // {
        //     ScopeTimer _t(H.pt_.t_centroid_search);
        //     H.pt_.cnt_centroid_search++;
        //     H.searchL0Heaps((const void*)c.data(), (size_t)ef, cand_ids, top_ids, vis_ids);
        // }

        for (auto qi : queries){
            auto t0 = std::chrono::high_resolution_clock::now();
            auto res = H.continueFromSnapshotL0(
                (const void*)(xq.data()+qi*dim),
                (size_t)k,
                cand_ids, top_ids,
                (size_t)ef_warm,
                m
            );
            auto t1 = std::chrono::high_resolution_clock::now();
            if (per_query_time_sec){
                double dt = std::chrono::duration<double>(t1 - t0).count();
                if (qi < per_query_time_sec->size()) (*per_query_time_sec)[qi] += dt;
            }
            std::vector<idx_t> pred;
            {
                ScopeTimer _t(H.pt_.t_result_vectorize);
                while(!res.empty()){ pred.push_back((idx_t)res.top().second); res.pop(); }
                std::reverse(pred.begin(), pred.end());
            }
            out_topk[qi] = std::move(pred);
        }
        return {};
    }
};



// ---------- 参数与主程序 ----------
// ---- 新增：解析 a:s:b 或单值 ----
static std::vector<float> parse_R_targets(const std::string& raw){
    std::string s = raw;
    for (auto& ch : s) if (ch == ':') ch = ':'; // 全角转半角
    std::vector<float> out;
    if (s.find(':') != std::string::npos){
        // 形如 a:s:b
        std::stringstream ss(s);
        std::string a_str, st_str, b_str;
        if (std::getline(ss, a_str, ':') && std::getline(ss, st_str, ':') && std::getline(ss, b_str, ':')){
            double a = std::stod(a_str);
            double st= std::stod(st_str);
            double b = std::stod(b_str);
            if (std::abs(st) < 1e-12) { out.push_back((float)a); return out; }
            if ((st > 0 && a > b) || (st < 0 && a < b)) std::swap(a, b); // 容错
            // 包含端点
            if (st > 0){
                for (double x=a; x<=b+1e-12; x+=st) out.push_back((float)x);
            }else{
                for (double x=a; x>=b-1e-12; x+=st) out.push_back((float)x);
            }
            if (out.empty()) out.push_back((float)a);
            return out;
        }
    }
    // 单值
    try { out.push_back(std::stof(s)); } catch (...) {}
    return out;
}

struct Args {
    std::string dir, index_path;
    int ef=200, k=10, ef_warm=120;
    int clusters=8, iters=15; unsigned seed=42;
    float L=0;
    std::string load_synth_prefix;

    // 预测与出 L
    float R_target = 0.90f;
    float L_floor = 1.f;
    float L_step  = 0.05f;
    float L_safety = 0.0f;

    // 选择 L 的出法：rankm（默认，需 model_rank_m.txt）或 recall（需 recall_head.txt）
    std::string L_mode = "rankm";
    float gate_thresh = 0.5f;

    // 模型文件
    std::string model_dir = "model_out_txt";
    std::string model_A_txt = "model_A_efc.txt";
    std::string model_B_txt = "model_B_efw.txt";
    // std::string model_gate_txt = "model_gate.txt";     // 可选
    std::string model_rank_txt = "model_rank_m.txt";   // L_mode=rankm 时需要
    std::string recall_head_txt = "recall_head.txt";   // L_mode=recall 时需要

    // ---- 新增：R_target 网格与 CSV 输出 ----
    std::vector<float> R_targets;  // 若非空，则按网格多次运行
    std::string csv_out;           // 输出路径，默认 data_dir/grid_results.csv
    // 新增：每个 query 的明细 CSV 输出路径（可选）。若非空则输出列：target_recall,qid,search_time_s,recall
    std::string per_query_csv_out;
};

static void usage(){
    std::cout<<"Usage:\n  run_hnsw_cluster_consensus <data_dir> [index_path]\n"
             <<"    --k <int> --ef <int> --ef_warm <int>\n"
             <<"    --clusters <int> --iters <int> --seed <uint>\n"
             <<"    --L <float> --load_synth_prefix <path>\n"
             <<"    --R_target <float|a:s:b> --L_floor <float> --L_step <float> --L_safety <float>\n"
             <<"    --L_mode <rankm|recall> --gate_thresh <float>\n"
             <<"    --model_dir <dir> --model_A <txt> --model_B <txt> --model_gate <txt> --model_rank <txt> --recall_head <txt>\n"
             <<"    --csv_out <path> --per_query_csv <path>\n";
}
static Args parse_args(int argc, char** argv){
    if (argc<2){ usage(); std::exit(1); }
    Args a; a.dir=argv[1];
    a.index_path = (argc>2 && argv[2][0]!='-') ? argv[2] : a.dir + "/base.hnsw";
    a.csv_out = a.dir + "/grid_results.csv"; // 默认 CSV 输出
    int i = (argc>2 && argv[2][0]!='-') ? 3 : 2;
    for (; i<argc; ++i){
        std::string s=argv[i]; auto next=[&](){ if(i+1>=argc){std::cerr<<"missing after "<<s<<"\n"; std::exit(1);} return std::string(argv[++i]); };
        if (s=="--k") a.k=std::stoi(next());
        else if (s=="--ef") a.ef=std::stoi(next());
        else if (s=="--ef_warm") a.ef_warm=std::stoi(next());
        else if (s=="--clusters") a.clusters=std::stoi(next());
        else if (s=="--iters") a.iters=std::stoi(next());
        else if (s=="--seed") a.seed=(unsigned)std::stoul(next());
        else if (s=="--load_synth_prefix") a.load_synth_prefix=next();
        else if (s=="--L") a.L=std::stof(next());
        else if (s=="--R_target"){
            std::string v = next();
            a.R_targets = parse_R_targets(v);
            if (!a.R_targets.empty()) a.R_target = a.R_targets.front();
        }
        else if (s=="--L_floor")  a.L_floor  = std::stof(next());
        else if (s=="--L_step")   a.L_step   = std::stof(next());
        else if (s=="--L_safety") a.L_safety = std::stof(next());
        else if (s=="--L_mode")   a.L_mode   = next();
        else if (s=="--gate_thresh") a.gate_thresh = std::stof(next());
        else if (s=="--model_dir") a.model_dir = next();
        else if (s=="--model_A")  a.model_A_txt = next();
        else if (s=="--model_B")  a.model_B_txt = next();
        // else if (s=="--model_gate")  a.model_gate_txt = next();
        else if (s=="--model_rank")  a.model_rank_txt = next();
        else if (s=="--recall_head") a.recall_head_txt = next();
        else if (s=="--csv_out") a.csv_out = next();
        else if (s=="--per_query_csv") a.per_query_csv_out = next();
        else { std::cerr<<"Unknown arg "<<s<<"\n"; usage(); std::exit(1); }
    }
    return a;
}

int main(int argc, char** argv){
    
    Args args = parse_args(argc, argv);
    auto path_join = [](const std::string& a, const std::string& b){
        if (a.empty()) return b;
        if (a.back()=='/'||a.back()=='\\') return a+b;
        return a + "/" + b;
    };
    std::vector<std::string> featsA_names, featsB_names, featsM_names;
    {
        std::string meta_path = path_join(args.model_dir, "meta.json");
        std::ifstream fin(meta_path);
        if (fin) {
            json j; fin >> j;
            auto try_get = [&](const char* key, std::vector<std::string>& out){
                if (j.contains(key) && j[key].is_array()) {
                    out.clear();
                    for (auto& v : j[key]) if (v.is_string()) out.push_back(v.get<std::string>());
                }
            };
            try_get("features_A_used",        featsA_names);
            try_get("features_B_used",        featsB_names);
            try_get("features_rank_m_used",   featsM_names);
            std::cout << "[meta] loaded feature orders: "
                    << "A=" << featsA_names.size() << ", "
                    << "B=" << featsB_names.size() << ", "
                    << "M=" << featsM_names.size() << "\n";
        } else {
            std::cout << "[meta] " << meta_path << " not found. Fallback to legacy fixed feature order.\n";
        }
    }
    // base
    std::string base_path  = first_existing(args.dir, {"base.fbin","base.2.5M.fbin","base.10M.fbin"});
    std::vector<float> xb; int dim=0; idx_t nb = read_fbin(base_path.c_str(), xb, dim);
    hnswlib::L2Space space(dim);

    // HNSW
    const size_t M=32, efc=200;
    WarmHierarchicalNSW hnsw(&space, nb, M, efc);
    if (std::filesystem::exists(args.index_path)){
        hnsw.loadIndex(args.index_path, &space, nb);
    }else{
        for (idx_t i=0;i<nb;++i) hnsw.addPoint(xb.data()+i*dim, i);
        hnsw.saveIndex(args.index_path);
    }
    hnsw.setEf(args.ef);

    // 加载 A/B 与 Gate/Rank/RecallHead


    // 加载 A/B 与 Rank/RecallHead（Gate 已移除）
    GBDT modelA, modelB, modelRank;
    if (!modelA.load_from_txt(path_join(args.model_dir, args.model_A_txt))) { std::cerr<<"FATAL: cannot load A\n"; return 1; }
    if (!modelB.load_from_txt(path_join(args.model_dir, args.model_B_txt))) { std::cerr<<"FATAL: cannot load B\n"; return 1; }
    bool rank_ok = modelRank.load_from_txt(path_join(args.model_dir, args.model_rank_txt));
    if (!rank_ok && args.L_mode=="rankm"){ std::cerr<<"FATAL: L_mode=rankm but cannot load rank model\n"; return 1; }

    std::cout<<"[Models] loaded A(efc), B(efw)"
            << ((args.L_mode=="rankm")? ", Rank-M":"")
            << ((args.L_mode=="recall")? ", RecallHead":"")
            << "\n";

    RecallHead RHead;
    bool recall_ok = false;
    if (args.L_mode=="recall"){
        std::ifstream fin(path_join(args.model_dir, args.recall_head_txt));
        if (!fin){ std::cerr<<"FATAL: L_mode=recall but cannot open recall_head\n"; return 1; }
        std::string line;
        // 1) coef
        while (std::getline(fin, line)){
            if (line.empty() || line[0]=='#') continue;
            if (line.rfind("num_knots_S",0)==0) break;
            std::stringstream ss(line);
            std::string name; float c;
            if (ss >> name >> c){ RHead.names.push_back(name); RHead.coef.push_back(c); }
        }
        // 2) S
        int nS=0; { std::stringstream ss(line); std::string k; ss>>k>>nS;
            for (int i=0;i<nS;++i){ std::getline(fin, line); float x,y; std::stringstream s2(line); s2>>x>>y; RHead.mapS.xs.push_back(x); RHead.mapS.ys.push_back(y); } }
        // 3) C
        std::getline(fin, line); std::getline(fin, line); std::getline(fin, line);
        int nC=0; { std::stringstream ss2(line); std::string k; ss2>>k>>nC;
            for (int i=0;i<nC;++i){ std::getline(fin, line); float x,y; std::stringstream s3(line); s3>>x>>y; RHead.mapC.xs.push_back(x); RHead.mapC.ys.push_back(y); } }
        // 4) U
        std::getline(fin, line); std::getline(fin, line); std::getline(fin, line);
        int nU=0; { std::stringstream ss4(line); std::string k; ss4>>k>>nU;
            for (int i=0;i<nU;++i){ std::getline(fin, line); float x,y; std::stringstream s4(line); s4>>x>>y; RHead.mapU.xs.push_back(x); RHead.mapU.ys.push_back(y); } }
        recall_ok = true;
    }

    // queries/gt/labels
    if (args.load_synth_prefix.empty()) {
        std::cerr << "ERROR: --load_synth_prefix is required for queries/gt/labels\n"; return 1;
    }
    std::string xqf = args.load_synth_prefix + ".xq.fbin";
    std::string gtf = args.load_synth_prefix + ".gt.ibin";
    std::string labf= args.load_synth_prefix + ".labels.ibin";
    if (!std::filesystem::exists(xqf) || !std::filesystem::exists(gtf) || !std::filesystem::exists(labf)){
        std::cerr << "ERROR: Missing synth files under prefix: " << args.load_synth_prefix << "\n"
                  << "  expect: .xq.fbin, .gt.ibin, .labels.ibin\n";
        return 1;
    }
    std::vector<float> xq; int dq=0; idx_t nq = read_fbin(xqf.c_str(), xq, dq);
    if (dq!=dim){ std::cerr<<"Dim mismatch in xq: "<<dq<<" vs base "<<dim<<"\n"; return 1; }

    std::vector<int> gt_full; int d_gtk=0; idx_t ngt_rows = read_ibin(gtf.c_str(), gt_full, d_gtk);
    if (ngt_rows < nq){ std::cerr << "Loaded gt rows < nq\n"; return 1; }
    std::vector<int> gt((size_t)nq * args.k, -1);
    for (idx_t i=0;i<nq;++i){
        std::copy(
            gt_full.data() + (size_t)i * d_gtk,
            gt_full.data() + (size_t)i * d_gtk + std::min(args.k, d_gtk),
            gt.begin() + (size_t)i * args.k
        );
    }

    // labels → Oracle 聚类
    std::vector<int> labels; int d_lab=0; idx_t n_lab = read_ibin(labf.c_str(), labels, d_lab);
    if ((idx_t)n_lab != nq || d_lab != 1) { std::cerr << "Loaded labels size mismatch (expect nq x 1)\n"; return 1; }

    // 分簇
    std::vector<std::vector<idx_t>> clusters;
    {
        int maxlab=-1; for (int v: labels) if (v>maxlab) maxlab=v;
        clusters.assign((size_t)std::max(1,maxlab+1), {});
        for (idx_t i=0;i<nq;++i){ int c=labels[(size_t)i]; if (c>=0) clusters[(size_t)c].push_back(i); }
        std::cout<<"[Oracle] clusters="<<clusters.size()<<"\n";
    }

    // 质心函数
    auto centroid = [&](const std::vector<idx_t>& ids){
        double t_centroid_sum = 0.0;
        ScopeTimer _t(t_centroid_sum);
        std::vector<float> c(dim,0.f);
        if (ids.empty()) return c;
        for (auto qi: ids){
            const float* qv = xq.data()+qi*dim;
            for (int j=0;j<dim;++j) c[j]+=qv[j];
        }
        for (int j=0;j<dim;++j) c[j]/=(float)ids.size();
        return c;
    };

    // ---- per-cluster features (base + probe256 trio) ----
    struct ClusterFeatBundle {
        std::vector<float> base; // 原来的 base 特征
        float lid_probe256 = 0.f;
        float rc_probe256  = 0.f;
        float exp2k_over_k_probe256 = 1.f;
    };

    auto cluster_features = [&](const std::vector<idx_t>& ids, const std::vector<float>& c_vec){
        // 这里不依赖外部计时总和，简化
        struct Feat {
            float cluster_size = 0.f;
            float cluster_size_log = 0.f;
            float log1p_cluster_size = 0.f;
            float cluster_density = 0.f;
            float cluster_radius_p50 = 0.f;
            float cluster_radius_p90 = 0.f;
            float dist_c_to_entryL0 = 0.f;
            float dist_c_top1_smallEF = 0.f;
        } F;

        F.cluster_size       = (float)ids.size();
        F.cluster_size_log   = (F.cluster_size > 0.f) ? std::log(F.cluster_size) : 0.f;
        F.log1p_cluster_size = std::log1p(F.cluster_size);

        std::vector<float> dists; dists.reserve(ids.size());
        for (auto qi: ids){
            const float* qv = xq.data()+qi*dim;
            dists.push_back(std::sqrt(l2sq(qv, c_vec.data(), dim)));
        }
        if (!dists.empty()){
            std::vector<float> tmp = dists;
            std::nth_element(tmp.begin(), tmp.begin()+tmp.size()/2, tmp.end());
            F.cluster_radius_p50 = tmp[tmp.size()/2];

            std::vector<float> tmp2 = dists;
            std::sort(tmp2.begin(), tmp2.end());
            size_t idx90 = (size_t)std::floor(0.9 * (double)(tmp2.size()-1));
            F.cluster_radius_p90 = tmp2[idx90];

            double mean = 0.0; for (float v: dists) mean += v;
            mean /= (double)dists.size();
            F.cluster_density = (float)(1.0 / (mean + 1e-6));
        } else {
            F.cluster_radius_p50 = 0.f;
            F.cluster_radius_p90 = 0.f;
            F.cluster_density    = 0.f;
        }

        hnswlib::tableint epL0 = hnsw.entryPointL0ForQuery((const void*)c_vec.data());
        if (epL0 == (hnswlib::tableint)-1) epL0 = hnsw.entrypoint();
        if (epL0 != (hnswlib::tableint)-1){
            const float* epv = xb.data() + (size_t)epL0 * dim;
            F.dist_c_to_entryL0 = std::sqrt(l2sq(c_vec.data(), epv, dim));
        } else {
            F.dist_c_to_entryL0 = 0.f;
        }

        const size_t smallEF    = 128;
        const size_t smallEF256 = 256;
        std::vector<hnswlib::tableint> cand128, top128, vis128;
        hnsw.searchL0Heaps((const void*)c_vec.data(), (size_t)smallEF, cand128, top128, vis128);
        if (!top128.empty()){
            auto id0 = top128.front();
            const float* xv = xb.data() + (size_t)id0 * dim;
            F.dist_c_top1_smallEF = std::sqrt(l2sq(c_vec.data(), xv, dim));
        } else {
            F.dist_c_top1_smallEF = 0.f;
        }

        std::vector<hnswlib::tableint> cand256, top256, vis256;
        hnsw.searchL0Heaps((const void*)c_vec.data(), (size_t)smallEF256, cand256, top256, vis256);

        float lid, rc, exp2; compute_lid_rc_expansion_from_top(hnsw, c_vec.data(), dim, top256, 10, lid, rc, exp2);

        float entry_dist_norm = (F.cluster_radius_p50 > 0.f) ? (F.dist_c_to_entryL0 / F.cluster_radius_p50) : 0.f;
        float radius_skew     = (F.cluster_radius_p50 > 0.f) ? (F.cluster_radius_p90 / F.cluster_radius_p50) : 0.f;

        ClusterFeatBundle B;
        B.base = {
            F.cluster_size,
            F.cluster_size_log,
            F.log1p_cluster_size,
            F.cluster_density,
            F.cluster_radius_p50,
            F.cluster_radius_p90,
            radius_skew,
            F.dist_c_to_entryL0,
            entry_dist_norm,
            F.dist_c_top1_smallEF,
            (float)topk_overlap_ratio_limited(top128, top256, (int)std::min<size_t>(args.k, std::min(top128.size(), top256.size()))),
            (float)topk_jaccard_limited      (top128, top256, (int)std::min<size_t>(args.k, std::min(top128.size(), top256.size())))
        };
        B.lid_probe256 = lid;
        B.rc_probe256  = rc;
        B.exp2k_over_k_probe256 = exp2;
        return B;
    };

    ClusterConsensusSearch runner(hnsw, space, dim, args.k);

    // ---- 运行目标列表（单值或网格）----
    std::vector<float> target_list = args.R_targets.empty() ? std::vector<float>{args.R_target} : args.R_targets;

    // ---- 保存 CSV 行 ----
    struct Row { float target; double qps; float recall; };
    std::vector<Row> rows;

    for (size_t ridx = 0; ridx < target_list.size(); ++ridx){
        args.R_target = target_list[ridx];
        std::cout << "\n=== RUN for target_recall=" << std::fixed << std::setprecision(4) << args.R_target << " ===\n";

        // 输出容器
        std::vector<std::vector<idx_t>> out_topk(nq);
        // 每个 query 的搜索时间（秒）与 recall
        std::vector<double> per_query_time(nq, 0.0);
        std::vector<float>  per_query_recall(nq, 0.0f);

        // 计时累加（每次 run 重置）
        double t_modelA = 0.0, t_modelB = 0.0, t_recall_head = 0.0, t_modelG=0.0, t_modelR=0.0;
        long long cnt_modelA = 0, cnt_modelB = 0, cnt_recall_head = 0, cnt_modelG=0, cnt_modelR=0;

        double t_feat_extract = 0.0;
        double t_feat_small128 = 0.0;
        double t_feat_small256 = 0.0;

        double t_centroid_sum = 0.0;
        double t_cluster_search_total = 0.0;
        double t_eval_subset = 0.0;
        double t_logging = 0.0;

        // 计时：总耗时
        auto start_time = std::chrono::high_resolution_clock::now();

        size_t total_incl_by_bound = 0, total_incl_by_notfull = 0;
        size_t clusters_processed = 0;

        for (size_t ci = 0; ci < clusters.size(); ++ci){
            auto& C = clusters[ci];
            if (C.empty()) continue;
            ++clusters_processed;

            std::vector<float> c = centroid(C); // 质心
            std::vector<idx_t> remain;
            size_t incl_by_bound = 0, incl_by_notfull = 0;

            // per-cluster features
            // 1) 先算 per-cluster 基础特征 FB（你已有）
            ClusterFeatBundle FB = cluster_features(C, c);

            // 2) 先构造一个 FeatureBank（先只放 base+probe256+recall），用于 A
            FeatureBank F;
            const std::vector<std::string> base_names = {
            "cluster_size","cluster_size_log","log1p_cluster_size",
            "cluster_density","cluster_radius_p50","cluster_radius_p90","radius_skew",
            "dist_centroid_to_entryL0","entry_dist_norm",
            "dist_centroid_top1_smallEF",
            "overlap128_vs_256","jaccard128_vs_256",
            };
            for (size_t i=0;i<base_names.size();++i) F.kv[base_names[i]] = FB.base[i];
            F.kv["lid_probe256_k10"]                = FB.lid_probe256;
            F.kv["rc_probe256_k10"]                 = FB.rc_probe256;
            F.kv["expansion2k_over_k_probe256_k10"] = FB.exp2k_over_k_probe256;
            F.kv["recall_at_k"]                     = args.R_target;

            // ---- A: efc
            std::vector<float> xA = featsA_names.empty()
                ? std::vector<float>{
                    F.get("cluster_size"), F.get("cluster_size_log"), F.get("log1p_cluster_size"),
                    F.get("cluster_density"), F.get("cluster_radius_p50"), F.get("cluster_radius_p90"), F.get("radius_skew"),
                    F.get("dist_centroid_to_entryL0"), F.get("entry_dist_norm"),
                    F.get("dist_centroid_top1_smallEF"),
                    F.get("overlap128_vs_256"), F.get("jaccard128_vs_256"),
                    F.get("lid_probe256_k10"), F.get("rc_probe256_k10"), F.get("expansion2k_over_k_probe256_k10"),
                    F.get("recall_at_k"),
                }
                : vector_from_names(featsA_names, F);

            float efc_hat_log = 0.f;
            { ScopeTimer _tm(t_modelA); efc_hat_log = modelA.predict_sum(xA); ++cnt_modelA; }
            int efc_hat = std::max(1, (int)std::round(std::expm1((double)efc_hat_log)));
            F.kv["efc"]     = (float)efc_hat;
            F.kv["log_efc"] = std::log1p((float)efc_hat);

            // ---- 用 efc_hat 搜索质心，得到 efc 侧三元组 + cand/top
            std::vector<hnswlib::tableint> candE, topE, visE;
            hnsw.searchL0Heaps((const void*)c.data(), (size_t)efc_hat, candE, topE, visE);
            float lid_efc=0.f, rc_efc=0.f, exp_efc=1.f;
            compute_lid_rc_expansion_from_top(hnsw, c.data(), dim, topE, 10, lid_efc, rc_efc, exp_efc);
            F.kv["lid_k_efc"]           = lid_efc;
            F.kv["rc_k_efc"]            = rc_efc;
            F.kv["expand2k_over_k_efc"] = exp_efc;

            // ---- B: ef_warm
            std::vector<float> xB = featsB_names.empty()
                ? std::vector<float>{
                    F.get("cluster_size"), F.get("cluster_size_log"), F.get("log1p_cluster_size"),
                    F.get("cluster_density"), F.get("cluster_radius_p50"), F.get("cluster_radius_p90"), F.get("radius_skew"),
                    F.get("dist_centroid_to_entryL0"), F.get("entry_dist_norm"),
                    F.get("dist_centroid_top1_smallEF"),
                    F.get("overlap128_vs_256"), F.get("jaccard128_vs_256"),
                    F.get("lid_k_efc"), F.get("rc_k_efc"), F.get("expand2k_over_k_efc"),
                    F.get("efc"), F.get("log_efc"),
                    F.get("recall_at_k"),
                }
                : vector_from_names(featsB_names, F);

            float efw_hat_log = 0.f;
            { ScopeTimer _tm(t_modelB); efw_hat_log = modelB.predict_sum(xB); ++cnt_modelB; }
            int efw_hat = std::max(1, (int)std::round(std::expm1((double)efw_hat_log)));
            F.kv["ef_warm"]      = (float)efw_hat;
            F.kv["log_efw"]      = std::log1p((float)efw_hat);
            F.kv["efw_over_efc"] = (float)efw_hat / std::max(1.0f, (float)efc_hat);

            // ---- Rank-M: m*，并得到 Lpred（你原逻辑）
            std::vector<float> xR = featsM_names.empty()
                ? std::vector<float>{
                    F.get("cluster_size"), F.get("cluster_size_log"), F.get("log1p_cluster_size"),
                    F.get("cluster_density"), F.get("cluster_radius_p50"), F.get("cluster_radius_p90"), F.get("radius_skew"),
                    F.get("dist_centroid_to_entryL0"), F.get("entry_dist_norm"),
                    F.get("dist_centroid_top1_smallEF"),
                    F.get("overlap128_vs_256"), F.get("jaccard128_vs_256"),
                    F.get("lid_k_efc"), F.get("rc_k_efc"), F.get("expand2k_over_k_efc"),
                    F.get("efc"), F.get("ef_warm"),
                    F.get("log_efc"), F.get("log_efw"), F.get("efw_over_efc"),
                    F.get("recall_at_k"),
                }
                : vector_from_names(featsM_names, F);

            double m_hat = 0.0;
            { ScopeTimer _tm(t_modelR); ++cnt_modelR; m_hat = std::expm1((double)modelRank.predict_sum(xR)); }
            if (!std::isfinite(m_hat)) m_hat = 0.0;

            float Lpred = (float)(m_hat / std::max(1.0f, (float)efw_hat));
            Lpred = std::max(Lpred, args.L_floor);
            float L_cap = std::max(1.0f, (float)efc_hat / std::max(1.0f, (float)efw_hat));
            Lpred = std::min(Lpred + args.L_safety, L_cap);
            if (args.L_step > 1e-9f) Lpred = std::ceil(Lpred / args.L_step) * args.L_step;

            std::cout << std::fixed << std::setprecision(4)
                    << "[Cluster " << ci << "] |Q|=" << C.size()
                    << "  efc_hat=" << efc_hat
                    << "  efw_hat=" << efw_hat
                    << "  m*=" << (double)m_hat
                    << "  Lpred=" << Lpred << "\n";

            // ---- 执行搜索（使用这次 efc_hat 派生的 candE/topE）
            {
                ScopeTimer _t(t_cluster_search_total);
                runner.run_one_cluster_fixed_c(
                    c, C, xq, xb, (size_t)efc_hat, (int)efw_hat, remain, out_topk,
                    incl_by_bound, incl_by_notfull, (float)m_hat, &per_query_time, candE, topE
                );
            }


            float recall_c = 0.f;
            { ScopeTimer _t(t_eval_subset); recall_c = compute_recall_subset(out_topk, gt, args.k, C); }
            { ScopeTimer _t(t_logging);
              std::cout << std::fixed << std::setprecision(4)
                        << "    -> recall@" << args.k << " = " << recall_c << "\n"; }

            total_incl_by_bound   += incl_by_bound;
            total_incl_by_notfull += incl_by_notfull;
        }

        // 结束计时
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
        double total_time_seconds = duration.count() / 1000000.0;
        double qps = nq / total_time_seconds;

        // 计算 recall
        float recall = compute_recall(out_topk, gt, args.k, (int)nq);

        // 计算每个 query 的 recall（使用已裁剪的 gt: nq x k）
        {
            int per_row = (int)gt.size() / (int)nq; // == k
            int expect = std::min(args.k, per_row);
            for (idx_t qi = 0; qi < nq; ++qi){
                int hit = 0;
                const auto& R = out_topk[qi];
                for (int j=0; j<expect; ++j){
                    int g = gt[(size_t)qi * per_row + j];
                    if (g < 0) break;
                    for (int t=0; t<std::min((int)R.size(), args.k); ++t){
                        if ((int)R[t] == g){ ++hit; break; }
                    }
                }
                per_query_recall[qi] = (expect>0)? ((float)hit / (float)expect) : 0.0f;
            }
        }

        // 打印结果
        std::cout << "\n=== HNSW Cluster Consensus (centroid warm-share; L_mode="<<args.L_mode<<") ===" << std::endl;
        std::cout << "TargetRecall="<< std::fixed << std::setprecision(4) << args.R_target
                  << " | Base: nb="<<nb<<" dim="<<dim<<"  Queries: nq="<<nq<<"\n";
        std::cout << "ef="<<args.ef<<" k="<<args.k<<"  ef_warm="<<args.ef_warm<<"\n";
        std::cout << "Total time: " << total_time_seconds << " s  |  QPS: " << qps << std::endl;
        std::cout << "Recall@" << args.k << ": " << recall << std::endl;

        // 保存该 run 的 CSV 数据
        rows.push_back(Row{args.R_target, qps, recall});

        // （保留的 profiling 输出，不影响 CSV，也不计入 total_time_seconds）
        const auto& PT = hnsw.profile_times();
        auto pct = [&](double x){ return (total_time_seconds>0)? (100.0 * x / total_time_seconds) : 0.0; };
        auto avg_or0 = [](double t, long long n){ return (n>0) ? (t / (double)n) : 0.0; };

        std::cout << "\n[Profiling] continueFromSnapshotL0 (coarse 4 parts)\n";
        std::cout << "  centroid_search  : " << PT.t_centroid_search  << " s"
                  << "  (calls=" << PT.cnt_centroid_search << ", avg="
                  << (PT.cnt_centroid_search? (PT.t_centroid_search / PT.cnt_centroid_search) : 0.0) << " s)\n";
        std::cout << "  try_emplace_cand : " << PT.t_try_emplace_cand << " s"
                  << "  (calls=" << PT.cnt_try_cand << ", avg="
                  << avg_or0(PT.t_try_emplace_cand, PT.cnt_try_cand) << " s)\n";
        std::cout << "  try_emplace_top  : " << PT.t_try_emplace_top  << " s"
                  << "  (calls=" << PT.cnt_try_top  << ", avg="
                  << avg_or0(PT.t_try_emplace_top, PT.cnt_try_top)   << " s)\n";
        std::cout << "  while_expand     : " << PT.t_while_expand     << " s"
                  << "  (" << pct(PT.t_while_expand) << "% of total)\n";

        // 写每个 query 的 CSV（在总计时之后执行，不计入 total_time_seconds）
        if (!args.per_query_csv_out.empty()){
            std::ios_base::openmode mode = std::ios::out;
            if (ridx > 0) mode |= std::ios::app; // 多个 R_target 时追加
            std::ofstream qout(args.per_query_csv_out, mode);
            if (!qout){
                std::cerr << "[WARN] cannot open per-query CSV for write: " << args.per_query_csv_out << "\n";
            } else {
                if (ridx == 0) qout << "target_recall,qid,search_time_s,recall\n";
                qout << std::fixed << std::setprecision(6);
                for (idx_t qi = 0; qi < nq; ++qi){
                    qout << args.R_target << "," << qi << "," << per_query_time[qi] << "," << per_query_recall[qi] << "\n";
                }
                std::cout << "[Per-Query CSV] wrote nq=" << nq << " rows to " << args.per_query_csv_out << "\n";
            }
        }
    }

    // ---- 写出 CSV ----
    {
        std::ofstream fout(args.csv_out);
        if (!fout){
            std::cerr << "[WARN] cannot open CSV for write: " << args.csv_out << "\n";
        } else {
            fout << "target_recall,qps,recall\n";
            fout << std::fixed << std::setprecision(6);
            for (const auto& r : rows){
                fout << r.target << "," << r.qps << "," << r.recall << "\n";
            }
            std::cout << "\n[CSV] wrote " << rows.size() << " rows to " << args.csv_out << "\n";
        }
    }

    return 0;
}
